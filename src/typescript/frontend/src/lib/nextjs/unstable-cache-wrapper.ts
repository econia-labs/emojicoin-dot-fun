/* eslint-disable @typescript-eslint/no-explicit-any */
import "server-only";

import { APTOS_NETWORK } from "lib/env";
import { unstable_cache } from "next/cache";

type Callback = (...args: any[]) => Promise<any>;

const MIN_KEY_LENGTH = 8;

/**
 * A more stable version of `unstable_cache`, achieved with a proxy object to update the callback
 * function's `.toString()` function and `.name` field.
 */
export function unstableCacheWrapper<T extends Callback>(
  cb: T,
  /**
   * The unique key or combination of keys to use for uniqueness instead of the `cb.toString()`.
   * This should functionally replace the uniqueness generated by the closure's stringified function
   * body at runtime.
   * If the uniqueness of the function you're passing shouldn't depend on the function body, you
   * can simply pass a unique function name or something along those lines.
   * It's used to replace to `cb.toString()` inside the `unstable_cache` cache key generation.
   */
  uniqueKeyParts: Exclude<string, ""> | string[],
  options: {
    /**
     * The revalidation interval in seconds.
     */
    revalidate?: number | false;
    tags?: string[];
  }
): T {
  const uniqueEntryLabel = Array.isArray(uniqueKeyParts)
    ? uniqueKeyParts.join(",")
    : uniqueKeyParts;
  // Enforce some arbitrary minimum for the cache key length.
  if (uniqueEntryLabel.length < MIN_KEY_LENGTH) {
    throw new Error(
      `Cache key must be at least ${MIN_KEY_LENGTH} characters. Got: ${uniqueEntryLabel}`
    );
  }

  // Add the `uniqueKey` to the `tags` array if it's not already there.
  const staticTags = new Set([uniqueEntryLabel, ...(options?.tags ?? [])]);
  const baseTags = Array.from(staticTags);

  // Stabilize the final callback and call `unstable_cache` with it.
  const stabilizedWithExplicitTags = async (...args: any[]) => {
    const functionCallTag = prettifyFunctionCall(uniqueEntryLabel, ...args);
    // Only add the function call tag if there are args, otherwise it's the same as the label.
    const tags = !args.length ? baseTags : [...baseTags, functionCallTag];
    const stabilizedProxy = createStabilizedProxy(cb, uniqueEntryLabel);
    return unstable_cache(stabilizedProxy, [uniqueEntryLabel], {
      revalidate: options.revalidate,
      tags,
    })(...args);
  };

  return stabilizedWithExplicitTags as T;
}

/**
 * Prettify a function call invocation by sanitizing and formatting its name and its arg inputs.
 * This makes it easy to debug and revalidate/invalidate invocations with specific arguments.
 */
function prettifyFunctionCall(uniqueKey: string, ...args: any[]) {
  const encodedArgs = JSON.stringify(args, (_, v) =>
    typeof v === "string" ? encodeURIComponent(v) : v
  );
  const argsWithoutParens = encodedArgs.replace(/^\[(.*)\]$/, "$1");
  return `${uniqueKey}(${argsWithoutParens})`;
}

/**
 * Creates a proxy object for a function and updates the proxy's `.toString()` and `.name` fields to
 * return the passed in cache key instead.
 *
 * The `cb.toString()` function used in the cache key generation in `unstable_cache` is
 * unreliable and sometimes even results in different keys for the same exact function due to
 * code minification.
 *
 * e.g., `() => func.a();` might minify to `() => func.o();` non-deterministically.
 *
 * To fix this, this function creates a Proxy object on the underlying callback function and updates
 * its `.toString()` function. This facilitates stabilizing the cache key generation inside
 * `unstable_cache` without having to rely on side effects from altering the underlying cb object.
 *
 * This fixes the issue of non-deterministic keys generated for the `unstable_cache` function.
 */
export function createStabilizedProxy<T extends Callback>(cb: T, uniqueKey: string): T {
  return new Proxy(cb, {
    get(target, prop, receiver) {
      if (prop === "toString") return () => `${uniqueKey}__${APTOS_NETWORK}`;
      if (prop === "name") return `${uniqueKey}__${APTOS_NETWORK}`;
      return Reflect.get(target, prop, receiver);
    },
  });
}
