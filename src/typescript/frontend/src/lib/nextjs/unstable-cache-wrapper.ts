/* eslint-disable @typescript-eslint/no-explicit-any */

import { IS_NEXT_BUILD_PHASE } from "lib/server-env";
import { unstable_cache } from "next/cache";

import { unstableCacheKeyGenerator } from "./generate-cache-key";

type Callback = (...args: any[]) => Promise<any>;

const buildCache = IS_NEXT_BUILD_PHASE ? new Map<string, Promise<{}>>() : undefined;

const MIN_KEY_LENGTH = 8;

/**
 * A more stable and efficient version of `unstable_cache`, achieved with a proxy object to update
 * the callback function's `.toString()` function and `.name` field, while also deduplicating
 * fetches at build time. See more information below.
 *
 * BUILD TIME DEDUPING:
 * Since `unstable_cache` nor the fetch deduping efforts properly work at build time when used in
 * the prerender for `generateStaticParams`, it's necessary to memoize the value of fetch results
 * manually to avoid making repeated queries/fetches.
 *
 * With 2,000+ markets in production, this function removes thousands of extra queries at build time
 * when running pre-rendered pages from `generateStaticParams`.
 *
 * FORCED UNIQUE KEY GENERATION:
 * The `cb.toString()` function used in the cache key generation in `unstable_cache` is
 * unreliable and sometimes even results in different keys for the same exact function due to
 * code minification.
 *
 * e.g., `() => func.a();` might minify to `() => func.o();` non-deterministically.
 *
 * To fix this, this function creates a Proxy object on the underlying callback function and updates
 * its `.toString()` function. This facilitates stabilizing the cache key generation inside
 * `unstable_cache` without having to rely on side effects from altering the underlying cb object.
 */
export function unstableCacheWrapper<T extends Callback>(
  cb: T,
  /**
   * The unique key or combination of keys to use for uniqueness instead of the `cb.toString()`.
   * This should functionally replace the uniqueness generated by the closure's stringified function
   * body at runtime.
   * If the uniqueness of the function you're passing shouldn't depend on the function body, you
   * can simply pass a unique function name or something along those lines.
   * It's used to replace to `cb.toString()` inside the `unstable_cache` cache key generation.
   */
  uniqueKeyParts: Exclude<string, ""> | string[],
  options: {
    /**
     * The revalidation interval in seconds.
     */
    revalidate?: number | false;
    tags?: string[];
  }
): T {
  try {
    const uniqueKey = Array.isArray(uniqueKeyParts) ? uniqueKeyParts.join(",") : uniqueKeyParts;
    // Enforce some arbitrary minimum for the cache key length.
    if (uniqueKey.length < MIN_KEY_LENGTH) {
      throw new Error(`Cache key must be at least ${MIN_KEY_LENGTH} characters. Got: ${uniqueKey}`);
    }
    const stableCallback = withStableNameAndToString(cb, uniqueKey);

    // Add the `uniqueKey` to the `tags` array if it's not already there.
    const dedupedTags = new Set([uniqueKey, ...(options?.tags ?? [])]);
    const tags = Array.from(dedupedTags);

    // Simplify the `keyParts` array and force the caller to stringify the key prior.
    const keyParts = [uniqueKey];

    const slightlyLessUnstableCache = async (...args: any[]) => {
      const encodedArgs = JSON.stringify(args, (_, v) =>
        typeof v === "string" ? encodeURIComponent(v) : v
      );
      const argsWithoutParens = encodedArgs.replace(/^\[(.*)\]$/, "$1");
      const functionCallTag = `${uniqueKey}(${argsWithoutParens})`;
      const cb = unstable_cache(stableCallback, keyParts, {
        revalidate: options.revalidate,
        // Add the stringified `args` to the tags for debuggability and so it's possible to
        // revalidate by an invocation with specific args passed to it.
        tags: args.length ? [...tags, functionCallTag] : tags,
      });
      return cb(...args);
    };

    // At runtime just return the `unstable_cache` function with stabilized key generation.
    if (!buildCache) return slightlyLessUnstableCache as unknown as T;

    // Otherwise, dedupe the build-time fetch with a cache key by unrolling the inner cache key
    // generation logic and storing the `unstable_cache` invocation in a lazy promise map.
    const cacheKeyFunction = unstableCacheKeyGenerator(stableCallback, keyParts);
    const memoizedBuildFetch = async (...args: any[]) => {
      const cacheKey = cacheKeyFunction(args);
      if (!buildCache.has(cacheKey)) {
        const promise = slightlyLessUnstableCache(...args);
        buildCache.set(cacheKey, promise);
      }
      const res = await buildCache.get(cacheKey);
      return res as ReturnType<T>;
    };
    return memoizedBuildFetch as unknown as T;
  } catch (e) {
    console.error(e);
    throw e;
  }
}

/**
 * Creates a proxy object for a function and updates the proxy's `.toString()` and `.name` fields to
 * return the passed in cache key instead.
 *
 * This fixes the issue of non-deterministic keys generated for the `unstable_cache` function.
 */
function withStableNameAndToString<T extends (...args: any[]) => any>(fn: T, cacheKey: string): T {
  return new Proxy(fn, {
    get(target, prop, receiver) {
      if (prop === "toString") return () => `${cacheKey}-stable-toString`;
      if (prop === "name") return `${cacheKey}-stable-name`;
      return Reflect.get(target, prop, receiver);
    },
  });
}
