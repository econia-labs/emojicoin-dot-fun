// cspell:word upstash
/* eslint-disable @typescript-eslint/no-explicit-any */
import "server-only";

import type { Redis } from "@upstash/redis";
import { CACHE_LOCK_RELEASE, IS_NEXT_BUILD_PHASE } from "lib/server-env";
import { unstable_cache } from "next/cache";

import { sleep } from "@/sdk/index";
import type { JsonValue } from "@/sdk/types/json-types";
import { logCacheDebug } from "@/sdk/utils/log-cache-debug";

import { generateUUID } from "./cache-handlers";
import { unstableCacheKeyGenerator } from "./generate-cache-key";
import { getCacheHandler, isPatchedCacheHandler } from "./get-incremental-cache";
import { createLock } from "./upstash-lock";

type Callback = (...args: any[]) => Promise<any>;

// Give access to the cache log for *.js files used in `next.config.mjs`.
// Must be here or the globalThis isn't accessed properly (if from `sdk`).
/* eslint-disable-next-line @typescript-eslint/no-explicit-any */
(globalThis as any).__logCacheDebug = logCacheDebug;

/**
 * BUILD TIME DEDUPING:
 * Since `unstable_cache` nor the fetch deduping efforts properly work at build time when used in
 * the prerender for `generateStaticParams`, it's necessary to memoize the value of fetch results
 * manually to avoid making repeated queries/fetches.
 *
 * With 2,000+ markets in production, this function removes thousands of extra queries at build time
 * when running pre-rendered pages from `generateStaticParams`.
 */
const buildCache = IS_NEXT_BUILD_PHASE ? new Map<string, Promise<JsonValue>>() : undefined;
const MIN_KEY_LENGTH = 8;

/**
 * The global TTL for all recently updated CDN entries on Vercel.
 * @see {@link https://vercel.com/docs/incremental-static-regeneration}
 */
const CDN_TTL_MS = 300;

/**
 * A more stable and efficient version of `unstable_cache`, achieved with a proxy object to update
 * the callback function's `.toString()` function and `.name` field and deduplication through a
 * redis lock/release mechanism.
 *
 * This should be used for any expensive queries/fetches that should be globally deduped.
 */
export function unstableCacheWrapper<T extends Callback>(
  cb: T,
  /**
   * The unique key or combination of keys to use for uniqueness instead of the `cb.toString()`.
   * This should functionally replace the uniqueness generated by the closure's stringified function
   * body at runtime.
   * If the uniqueness of the function you're passing shouldn't depend on the function body, you
   * can simply pass a unique function name or something along those lines.
   * It's used to replace to `cb.toString()` inside the `unstable_cache` cache key generation.
   */
  uniqueKeyParts: Exclude<string, ""> | string[],
  options: {
    /**
     * The revalidation interval in seconds.
     */
    revalidate?: number | false;
    tags?: string[];
  }
): T {
  const uniqueEntryLabel = Array.isArray(uniqueKeyParts)
    ? uniqueKeyParts.join(",")
    : uniqueKeyParts;
  // Enforce some arbitrary minimum for the cache key length.
  if (uniqueEntryLabel.length < MIN_KEY_LENGTH) {
    throw new Error(
      `Cache key must be at least ${MIN_KEY_LENGTH} characters. Got: ${uniqueEntryLabel}`
    );
  }

  const finalStableCb = stabilizedWithExplicitTags(cb, uniqueEntryLabel, options);

  // At runtime just return the `unstable_cache` function with stabilized key generation.
  if (!buildCache) return finalStableCb as T;

  // Otherwise, dedupe the build-time fetch with a cache key by unrolling the inner cache key
  // generation logic and storing the `unstable_cache` invocation in a lazy promise map.
  // This deduplicates ~80% of fetches when the CDN caching mechanism isn't available.
  const memoizedBuildFetch = async (...args: any[]) => {
    const keyParts = createKeyParts(uniqueEntryLabel);
    const cacheKey = unstableCacheKeyGenerator(finalStableCb, keyParts)(...args);
    if (!buildCache.has(cacheKey)) {
      const promise = finalStableCb(...args);
      buildCache.set(cacheKey, promise);
    }
    const res = await buildCache.get(cacheKey);
    return res as ReturnType<T>;
  };
  return memoizedBuildFetch as unknown as T;
}

/**
 * This function handles locking and releasing the key associated with the cache key for a given
 * `cb` function.
 *
 * It transforms the function so that the lock must be acquired before calling the original
 * function. The exact purpose is to intercept the origin fetch with a lock/release mechanism so
 * that queries aren't called if there's already another revalidation occurring remotely.
 *
 * Since the `cb` function is only called in `unstable_cache` if the cache entry doesn't exist
 * (MISS), the lock is only acquired when `unstable_cache` determines that revalidation must occur.
 * It doesn't matter if it's synchronous or asynchronous here; ultimately, this is just meant to
 * reduce unnecessary load on the origin endpoint.
 *
 * For *background revalidation* fetches:
 * | Cache entry exists and is not stale         | HIT, no revalidation
 * | Cache entry exists and is stale             | STALE, asynchronous revalidation (not awaited)
 * | Cache entry does not exist                  | MISS, *forces* synchronous revalidation
 *
 * For *on demand* fetches, the possible scenarios are as follows:
 * | Cache entry exists and is not stale         | HIT, no revalidation
 * | Cache entry exists and is stale             | STALE, *forces* synchronous revalidation
 * | Cache entry does not exist                  | MISS, *forces* synchronous revalidation
 *
 * @param cb The callback function passed to @see unstableCacheWrapper
 * @param uniqueEntryLabel The unique key passed to @see unstableCacheWrapper
 */
function addLockAndRelease<T extends Callback>(
  cb: T,
  // The unique cache key entry- not globally unique. e.g. `current-arena-info` or `getMarket(1)`
  uniqueEntryLabel: string,
  // The uuid for the function invocation.
  uuid: string,
  redis: Redis
) {
  if (!CACHE_LOCK_RELEASE) return cb;
  // Only used to generate the cache key since the function isn't properly curried and we can't
  // extract the args without intercepting the function call first.
  const stabilizedProxy = createStabilizedProxy(cb, uniqueEntryLabel);

  const newCb = async (...args: any[]) => {
    const cacheKey = unstableCacheKeyGenerator(stabilizedProxy, [uniqueEntryLabel])(...args);
    const lock = createLock(redis, cacheKey);
    const functionCallTag = prettifyFunctionCall(uniqueEntryLabel, ...args);

    let lockServiceFailure = false;

    const acquired = await lock.acquire({ uuid }).catch((e) => {
      lockServiceFailure = true;
      console.error(`Failed to acquire lock: ${e}`);
      return false;
    });

    if (acquired) {
      logCacheDebug({
        cacheKey,
        label: ["LOCK", "info"],
        msg: "Acquired lock!",
        fetchUrl: functionCallTag,
        alwaysLog: true,
      });
      return stabilizedProxy(...args).then((res) => {
        // Wait for the cache entry to update in storage and *then* release the lock.
        // Otherwise, multiple instances can acquire the lock before the CDN will show as fresh.
        // The file system cache will be faster at writing than the CDN so it works for that, too.
        sleep(CDN_TTL_MS).then(() =>
          lock.release().then((released) => {
            if (!released) {
              logCacheDebug({
                cacheKey,
                label: ["RELEASE", "error"],
                msg: "Failed to release lock.",
                fetchUrl: functionCallTag,
                uuid,
                alwaysLog: true,
              });
            }
          })
        );
        return res;
      });
    } else {
      // Lock service is most likely down- no reason to spin on the cache endpoint if it will just
      // keep returning stale. Fetch from origin directly.
      if (lockServiceFailure) {
        return stabilizedProxy(...args);
      }
      // If the lock wasn't acquired, return a callback that polls the cache entry several times
      // before trying to do an origin fetch. This is the brunt of the deduplication.
      // If polling fails, the function simply falls back to doing the original `unstable_callback`
      // implementation (with updated tags and info).
      const pollWithFallback = async (...args: any[]) => {
        const fc = getCacheHandler();
        if (fc && isPatchedCacheHandler(fc)) {
          const pollResult = await fc.pollCacheEntry<Awaited<ReturnType<T>>>({ cacheKey, uuid });
          if (pollResult) {
            return pollResult.value;
          }
        }
        // Otherwise, fallback to default `unstable_cache` behavior that doesn't deduplicate
        // origin fetches across different requests.
        const msg = `Failed to retrieve cache entry. Falling back to origin fetch. ${cacheKey}`;
        console.warn(msg);
        logCacheDebug({
          cacheKey,
          label: ["DUPLICATE WRITE", "warning"],
          msg: msg.split(cacheKey)[0].trim(),
          fetchUrl: functionCallTag,
          uuid,
          alwaysLog: true,
        });

        return stabilizedProxy(...args);
      };
      return pollWithFallback(...args);
    }
  };
  return newCb;
}

function prettifyFunctionCall(uniqueKey: string, ...args: any[]) {
  const encodedArgs = JSON.stringify(args, (_, v) =>
    typeof v === "string" ? encodeURIComponent(v) : v
  );
  const argsWithoutParens = encodedArgs.replace(/^\[(.*)\]$/, "$1");
  return `${uniqueKey}(${argsWithoutParens})`;
}

/**
 * Creates a proxy object for a function and updates the proxy's `.toString()` and `.name` fields to
 * return the passed in cache key instead.
 *
 * The `cb.toString()` function used in the cache key generation in `unstable_cache` is
 * unreliable and sometimes even results in different keys for the same exact function due to
 * code minification.
 *
 * e.g., `() => func.a();` might minify to `() => func.o();` non-deterministically.
 *
 * To fix this, this function creates a Proxy object on the underlying callback function and updates
 * its `.toString()` function. This facilitates stabilizing the cache key generation inside
 * `unstable_cache` without having to rely on side effects from altering the underlying cb object.
 *
 * This fixes the issue of non-deterministic keys generated for the `unstable_cache` function.
 */
function createStabilizedProxy<T extends Callback>(cb: T, uniqueKey: string): T {
  return new Proxy(cb, {
    get(target, prop, receiver) {
      if (prop === "toString") return () => `${uniqueKey}${process.env.BUILD_PREFIX || ""}`;
      if (prop === "name") return `${uniqueKey}${process.env.BUILD_PREFIX || ""}`;
      return Reflect.get(target, prop, receiver);
    },
  });
}

/**
 * Stabilize the final callback and call `unstable_cache` with it.
 *
 * The function call tag (used for debuggability and explicit tag revalidation) can't be created
 * without access to the runtime args, so instead of creating yet another wrapped callback, simply
 * couple the stabilization logic with the final explicit tags creation, call `unstable_cache` with
 * it, and return that.
 */
function stabilizedWithExplicitTags<T extends Callback>(
  cb: T,
  uniqueEntryLabel: string,
  options: {
    revalidate?: number | false;
    tags?: string[];
  }
) {
  // Add the `uniqueKey` to the `tags` array if it's not already there.
  const staticTags = new Set([uniqueEntryLabel, ...(options?.tags ?? [])]);
  const baseTags = Array.from(staticTags);

  const res = async (...args: any[]) => {
    // Add a unique tag to `tags` to be able to look up this unique function invocation in the
    // patched fetch cache.
    const uuid = generateUUID();
    const functionCallTag = prettifyFunctionCall(uniqueEntryLabel, ...args);
    // Only add it if it has args, otherwise it's just the same as the label with parentheses.
    const maybeFunctionCallTag = args.length ? [functionCallTag] : [];
    const tags = [...baseTags, uuid, ...maybeFunctionCallTag];
    const { redis } = CACHE_LOCK_RELEASE ?? {};
    const maybeWrappedLock = redis ? addLockAndRelease(cb, uniqueEntryLabel, uuid, redis) : cb;
    const stabilizedProxy = createStabilizedProxy(maybeWrappedLock, uniqueEntryLabel);
    return unstable_cache(stabilizedProxy, createKeyParts(uniqueEntryLabel), {
      revalidate: options.revalidate,
      // Add the stringified `args` to the tags for debuggability and so it's possible to
      // revalidate by an invocation with specific args passed to it.
      tags,
    })(...args);
  };

  return res as T;
}

// Consolidate the key parts creation behavior with this helper function.
function createKeyParts(uniqueKey: string) {
  return [uniqueKey];
}
