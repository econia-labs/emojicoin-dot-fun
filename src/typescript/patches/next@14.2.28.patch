diff --git a/dist/esm/server/lib/incremental-cache/fetch-cache.js b/dist/esm/server/lib/incremental-cache/fetch-cache.js
index ab0cbbcd7f155c619c0fddd59d7b3422fc0b3ae4..ddeb3a5bf49d9bd4378c14abf1b175a692e69d23 100644
--- a/dist/esm/server/lib/incremental-cache/fetch-cache.js
+++ b/dist/esm/server/lib/incremental-cache/fetch-cache.js
@@ -45,6 +45,7 @@ export default class FetchCache {
         return !!(ctx._requestHeaders["x-vercel-sc-host"] || process.env.SUSPENSE_CACHE_URL);
     }
     constructor(ctx){
+        console.log("------------------------------------------- esm fetch-cache.js");
         this.headers = {};
         this.headers["Content-Type"] = "application/json";
         if (CACHE_HEADERS_HEADER in ctx._requestHeaders) {
@@ -98,6 +99,8 @@ export default class FetchCache {
                 console.log("not using memory store for fetch cache");
             }
         }
+        console.log("Headers at the end of FetchCache constructor");
+        console.log(this.headers);
     }
     resetRequestCache() {
         memoryCache == null ? void 0 : memoryCache.reset();
@@ -242,6 +245,8 @@ export default class FetchCache {
             }
             return;
         }
+        console.log(`GET: dumping memory cache for: ${key}`);
+        console.log(memoryCache.dump());
         memoryCache == null ? void 0 : memoryCache.set(key, {
             value: data,
             lastModified: Date.now()
@@ -298,6 +303,8 @@ export default class FetchCache {
                 }
             }
         }
+        console.log(`${key}, this.cacheEndpoint: ${this.cacheEndpoint}`);
+        console.log(this.headers);
         return;
     }
 }
diff --git a/dist/esm/server/lib/incremental-cache/index.js b/dist/esm/server/lib/incremental-cache/index.js
index ea5838838ef20c3bc27664284bfc58d705f621db..9f409f25b3668ceabb649784c3ce5305a8011114 100644
--- a/dist/esm/server/lib/incremental-cache/index.js
+++ b/dist/esm/server/lib/incremental-cache/index.js
@@ -96,6 +96,7 @@ export class IncrementalCache {
         (_this_cacheHandler = this.cacheHandler) == null ? void 0 : (_this_cacheHandler_resetRequestCache = _this_cacheHandler.resetRequestCache) == null ? void 0 : _this_cacheHandler_resetRequestCache.call(_this_cacheHandler);
     }
     async unlock(cacheKey) {
+        console.error(`esm/server/lib/incremental-cache: UNLocking the incremental cache lock for key: ${cacheKey}`);
         const unlock = this.unlocks.get(cacheKey);
         if (unlock) {
             unlock();
@@ -104,6 +105,7 @@ export class IncrementalCache {
         }
     }
     async lock(cacheKey) {
+        console.error(`esm/server/lib/incremental-cache: Locking the incremental cache lock for key: ${cacheKey}`);
         if (process.env.__NEXT_INCREMENTAL_CACHE_IPC_PORT && process.env.__NEXT_INCREMENTAL_CACHE_IPC_KEY && process.env.NEXT_RUNTIME !== "edge") {
             const invokeIpcMethod = require("../server-ipc/request-utils").invokeIpcMethod;
             await invokeIpcMethod({
@@ -257,6 +259,7 @@ export class IncrementalCache {
     }
     // get data from cache if available
     async get(cacheKey, ctx = {}) {
+        console.error(`esm/server/lib/incremental-cache: GETTING the incremental cache lock for key: ${cacheKey}`);
         var _this_cacheHandler, _cacheData_value;
         if (process.env.__NEXT_INCREMENTAL_CACHE_IPC_PORT && process.env.__NEXT_INCREMENTAL_CACHE_IPC_KEY && process.env.NEXT_RUNTIME !== "edge") {
             const invokeIpcMethod = require("../server-ipc/request-utils").invokeIpcMethod;
@@ -340,6 +343,7 @@ export class IncrementalCache {
     }
     // populate the incremental cache with new data
     async set(pathname, data, ctx) {
+        console.error(`esm/server/lib/incremental-cache: SETTING the incremental cache lock for key: ${pathname}`);
         if (process.env.__NEXT_INCREMENTAL_CACHE_IPC_PORT && process.env.__NEXT_INCREMENTAL_CACHE_IPC_KEY && process.env.NEXT_RUNTIME !== "edge") {
             const invokeIpcMethod = require("../server-ipc/request-utils").invokeIpcMethod;
             return invokeIpcMethod({
diff --git a/dist/server/lib/incremental-cache/fetch-cache.js b/dist/server/lib/incremental-cache/fetch-cache.js
index 6274e90ea7fc65b2d89a9d9bd2ccc4ca121509f4..f383028727fe362c55a845c8e7307821b369b8cb 100644
--- a/dist/server/lib/incremental-cache/fetch-cache.js
+++ b/dist/server/lib/incremental-cache/fetch-cache.js
@@ -24,6 +24,18 @@ const CACHE_REVALIDATE_HEADER = "x-vercel-revalidate";
 const CACHE_FETCH_URL_HEADER = "x-vercel-cache-item-name";
 const CACHE_CONTROL_VALUE_HEADER = "x-vercel-cache-control";
 const DEBUG = Boolean(process.env.NEXT_PRIVATE_DEBUG_CACHE);
+
+const YELLOW = "\x1b[33m";
+const PURPLE = "\x1b[35m";
+const RESET = "\x1b[0m";
+const DARK_GRAY = "\x1b[90m";
+const RED = "\x1b[31m";
+const darkGray = (s) => `${DARK_GRAY}${s}${RESET}`;
+const yellow = (s) => `${YELLOW}${s}${RESET}`;
+const purple = (s) => `${PURPLE}${s}${RESET}`;
+const warning = (s) => `${RED}${s}${RESET}`;
+const withTime = (s) => console.log(`(${darkGray(new Date().toISOString())}) ${s}`);
+
 async function fetchRetryWithTimeout(url, init, retryIndex = 0) {
     const controller = new AbortController();
     const timeout = setTimeout(()=>{
@@ -57,7 +69,8 @@ class FetchCache {
         return true;
     }
     static isAvailable(ctx) {
-        return !!(ctx._requestHeaders["x-vercel-sc-host"] || process.env.SUSPENSE_CACHE_URL);
+        const res = !!(ctx._requestHeaders["x-vercel-sc-host"] || process.env.SUSPENSE_CACHE_URL);
+        return res;
     }
     constructor(ctx){
         this.headers = {};
@@ -168,6 +181,10 @@ class FetchCache {
             }
             return null;
         }
+        
+        if (DEBUG) {
+            console.log(yellow("*".repeat(100)));
+        }
         // memory cache is cleared at the end of each request
         // so that revalidate events are pulled from upstream
         // on successive requests
@@ -176,6 +193,7 @@ class FetchCache {
         // Get data from fetch cache. Also check if new tags have been
         // specified with the same cache key (fetch URL)
         if (this.cacheEndpoint && (!data || !hasFetchKindAndMatchingTags)) {
+            if (DEBUG) console.log(`mem-cache MISS: ${key} tags: ${tags.join("") || fetchUrl}`);
             try {
                 const start = Date.now();
                 const fetchParams = {
@@ -184,6 +202,9 @@ class FetchCache {
                     fetchUrl: fetchUrl,
                     fetchIdx
                 };
+                if (DEBUG || fetchUrl.trim().startsWith("unstable_cache")) {
+                    withTime(yellow("[GET]") + `   ${key} ` + `${yellow("for " + fetchUrl)}`);
+                }
                 const res = await fetch(`${this.cacheEndpoint}/v1/suspense-cache/${key}`, {
                     method: "GET",
                     headers: {
@@ -194,6 +215,7 @@ class FetchCache {
                     },
                     next: fetchParams
                 });
+
                 if (res.status === 429) {
                     const retryAfter = res.headers.get("retry-after") || "60000";
                     rateLimitedUntil = Date.now() + parseInt(retryAfter);
@@ -244,7 +266,10 @@ class FetchCache {
                     console.error(`Failed to get from fetch-cache`, err);
                 }
             }
+        } else {
+            if (DEBUG) console.log(`mem-cache HIT: ${key} tags: ${tags.join("") || fetchUrl}`);
         }
+        if (DEBUG) console.log(yellow("*".repeat(50)));
         return data || null;
     }
     async set(...args) {
@@ -257,11 +282,16 @@ class FetchCache {
             }
             return;
         }
+
+        
+        if (DEBUG) console.log(purple("*".repeat(100)));
+
         memoryCache == null ? void 0 : memoryCache.set(key, {
             value: data,
             lastModified: Date.now()
         });
         if (this.cacheEndpoint) {
+            if (DEBUG) console.log(`mem-cache SET: ${key} tags: ${tags.join("") || fetchUrl}`);
             try {
                 const start = Date.now();
                 if (data !== null && "revalidate" in data) {
@@ -285,6 +315,11 @@ class FetchCache {
                     fetchUrl,
                     fetchIdx
                 };
+
+                if (DEBUG || fetchUrl.trim().startsWith("unstable_cache")) {
+                    withTime(`${purple("[POST]")}  ${key + yellow(" for ")}${fetchUrl}`); 
+                }
+                
                 const res = await fetch(`${this.cacheEndpoint}/v1/suspense-cache/${key}`, {
                     method: "POST",
                     headers: {
@@ -313,6 +348,7 @@ class FetchCache {
                 }
             }
         }
+        if (DEBUG) console.log(purple("*".repeat(50)))
         return;
     }
 }
diff --git a/dist/server/lib/incremental-cache/index.js b/dist/server/lib/incremental-cache/index.js
index 754eee87cf0d60f034cb6c05ad87ac9ada5c93fe..0688d9b72ad0d05f3846e2c2d3f4f8d62a85f583 100644
--- a/dist/server/lib/incremental-cache/index.js
+++ b/dist/server/lib/incremental-cache/index.js
@@ -50,18 +50,19 @@ class IncrementalCache {
         this.hasCustomCacheHandler = Boolean(CurCacheHandler);
         if (!CurCacheHandler) {
             if (fs && serverDistDir) {
-                if (debug) {
-                    console.log("using filesystem cache handler");
-                }
                 CurCacheHandler = _filesystemcache.default;
             }
             if (_fetchcache.default.isAvailable({
                 _requestHeaders: requestHeaders
-            }) && minimalMode && fetchCache) {
+            }) && fetchCache) {
                 if (debug) {
                     console.log("using fetch cache handler");
                 }
                 CurCacheHandler = _fetchcache.default;
+            } else {
+                if (debug) {
+                    console.log("using filesystem cache handler");
+                }
             }
         } else if (debug) {
             console.log("using custom cache handler", CurCacheHandler.name);
diff --git a/dist/server/web/spec-extension/unstable-cache.js b/dist/server/web/spec-extension/unstable-cache.js
index 1cbb26c565dea760e48f2668e0f7e81582ea51d4..f2b486ad92cbc3fde7e447705775bc71f94f7707 100644
--- a/dist/server/web/spec-extension/unstable-cache.js
+++ b/dist/server/web/spec-extension/unstable-cache.js
@@ -12,6 +12,18 @@ const _constants = require("../../../lib/constants");
 const _patchfetch = require("../../lib/patch-fetch");
 const _staticgenerationasyncstorageexternal = require("../../../client/components/static-generation-async-storage.external");
 let noStoreFetchIdx = 0;
+
+const YELLOW = "\x1b[33m";
+const PURPLE = "\x1b[35m";
+const RESET = "\x1b[0m";
+const DARK_GRAY = "\x1b[90m";
+const RED = "\x1b[31m";
+const darkGray = (s) => `${DARK_GRAY}${s}${RESET}`;
+const yellow = (s) => `${YELLOW}${s}${RESET}`;
+const purple = (s) => `${PURPLE}${s}${RESET}`;
+const warning = (s) => `${RED}${s}${RESET}`;
+const withTime = (s) => console.log(`(${darkGray(new Date().toISOString())}) ${s}`);
+
 async function cacheNewResult(result, incrementalCache, cacheKey, tags, revalidate, fetchIdx, fetchUrl) {
     await incrementalCache.set(cacheKey, {
         kind: "FETCH",
@@ -132,6 +144,7 @@ function unstable_cache(cb, keyParts, options = {}) {
                                 store.pendingRevalidates = {};
                             }
                             // We run the cache function asynchronously and save the result when it completes
+                            withTime(`${darkGray("[STALE]")} ${cacheKey}` + darkGray(` for ${fetchUrl}`));
                             store.pendingRevalidates[invocationKey] = _staticgenerationasyncstorageexternal.staticGenerationAsyncStorage.run({
                                 ...store,
                                 // force any nested fetches to bypass cache so they revalidate
