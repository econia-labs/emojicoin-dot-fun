diff --git a/dist/esm/server/lib/incremental-cache/fetch-cache.js b/dist/esm/server/lib/incremental-cache/fetch-cache.js
index ab0cbbcd7f155c619c0fddd59d7b3422fc0b3ae4..ddeb3a5bf49d9bd4378c14abf1b175a692e69d23 100644
--- a/dist/esm/server/lib/incremental-cache/fetch-cache.js
+++ b/dist/esm/server/lib/incremental-cache/fetch-cache.js
@@ -45,6 +45,7 @@ export default class FetchCache {
         return !!(ctx._requestHeaders["x-vercel-sc-host"] || process.env.SUSPENSE_CACHE_URL);
     }
     constructor(ctx){
+        console.log("------------------------------------------- esm fetch-cache.js");
         this.headers = {};
         this.headers["Content-Type"] = "application/json";
         if (CACHE_HEADERS_HEADER in ctx._requestHeaders) {
@@ -98,6 +99,8 @@ export default class FetchCache {
                 console.log("not using memory store for fetch cache");
             }
         }
+        console.log("Headers at the end of FetchCache constructor");
+        console.log(this.headers);
     }
     resetRequestCache() {
         memoryCache == null ? void 0 : memoryCache.reset();
@@ -242,6 +245,8 @@ export default class FetchCache {
             }
             return;
         }
+        console.log(`GET: dumping memory cache for: ${key}`);
+        console.log(memoryCache.dump());
         memoryCache == null ? void 0 : memoryCache.set(key, {
             value: data,
             lastModified: Date.now()
@@ -298,6 +303,8 @@ export default class FetchCache {
                 }
             }
         }
+        console.log(`${key}, this.cacheEndpoint: ${this.cacheEndpoint}`);
+        console.log(this.headers);
         return;
     }
 }
diff --git a/dist/esm/server/lib/incremental-cache/index.js b/dist/esm/server/lib/incremental-cache/index.js
index ea5838838ef20c3bc27664284bfc58d705f621db..9f409f25b3668ceabb649784c3ce5305a8011114 100644
--- a/dist/esm/server/lib/incremental-cache/index.js
+++ b/dist/esm/server/lib/incremental-cache/index.js
@@ -96,6 +96,7 @@ export class IncrementalCache {
         (_this_cacheHandler = this.cacheHandler) == null ? void 0 : (_this_cacheHandler_resetRequestCache = _this_cacheHandler.resetRequestCache) == null ? void 0 : _this_cacheHandler_resetRequestCache.call(_this_cacheHandler);
     }
     async unlock(cacheKey) {
+        console.error(`esm/server/lib/incremental-cache: UNLocking the incremental cache lock for key: ${cacheKey}`);
         const unlock = this.unlocks.get(cacheKey);
         if (unlock) {
             unlock();
@@ -104,6 +105,7 @@ export class IncrementalCache {
         }
     }
     async lock(cacheKey) {
+        console.error(`esm/server/lib/incremental-cache: Locking the incremental cache lock for key: ${cacheKey}`);
         if (process.env.__NEXT_INCREMENTAL_CACHE_IPC_PORT && process.env.__NEXT_INCREMENTAL_CACHE_IPC_KEY && process.env.NEXT_RUNTIME !== "edge") {
             const invokeIpcMethod = require("../server-ipc/request-utils").invokeIpcMethod;
             await invokeIpcMethod({
@@ -257,6 +259,7 @@ export class IncrementalCache {
     }
     // get data from cache if available
     async get(cacheKey, ctx = {}) {
+        console.error(`esm/server/lib/incremental-cache: GETTING the incremental cache lock for key: ${cacheKey}`);
         var _this_cacheHandler, _cacheData_value;
         if (process.env.__NEXT_INCREMENTAL_CACHE_IPC_PORT && process.env.__NEXT_INCREMENTAL_CACHE_IPC_KEY && process.env.NEXT_RUNTIME !== "edge") {
             const invokeIpcMethod = require("../server-ipc/request-utils").invokeIpcMethod;
@@ -340,6 +343,7 @@ export class IncrementalCache {
     }
     // populate the incremental cache with new data
     async set(pathname, data, ctx) {
+        console.error(`esm/server/lib/incremental-cache: SETTING the incremental cache lock for key: ${pathname}`);
         if (process.env.__NEXT_INCREMENTAL_CACHE_IPC_PORT && process.env.__NEXT_INCREMENTAL_CACHE_IPC_KEY && process.env.NEXT_RUNTIME !== "edge") {
             const invokeIpcMethod = require("../server-ipc/request-utils").invokeIpcMethod;
             return invokeIpcMethod({
diff --git a/dist/server/base-server.js b/dist/server/base-server.js
index a437c1dd076e6fbc93a7e1c06104b36e4ad7cf2b..c29fa6bd65d0e9d7f008cc88756aff953c3106ec 100644
--- a/dist/server/base-server.js
+++ b/dist/server/base-server.js
@@ -1493,6 +1493,17 @@ class Server {
                 revalidate: metadata.revalidate
             };
         };
+        if (!!process.env.NEXT_PRIVATE_DEBUG_CACHE) {
+            console.log(`resolvedUrlPathname: ${resolvedUrlPathname}, ssgCacheKey: ${ssgCacheKey}`);
+            console.log({
+                MATCHES_isPreviewMode: !isPreviewMode,
+                MATCHES_isSSG: isSSG,
+                MATCHES_supportsDynamicResponse: !opts.supportsDynamicResponse,
+                MATCHES_isServerAction: !isServerAction,
+                MATCHES_minimalPostponed: !minimalPostponed,
+                MATCHES_isDynamicRSCRequest: !isDynamicRSCRequest,
+            });
+        }
         const cacheEntry = await this.responseCache.get(ssgCacheKey, async (hasResolved, previousCacheEntry, isRevalidating)=>{
             const isProduction = !this.renderOpts.dev;
             const didRespond = hasResolved || res.sent;
diff --git a/dist/server/lib/incremental-cache/fetch-cache.js b/dist/server/lib/incremental-cache/fetch-cache.js
index 6274e90ea7fc65b2d89a9d9bd2ccc4ca121509f4..d38d9a01e318d1a02f0cbd498b14e87a82aef825 100644
--- a/dist/server/lib/incremental-cache/fetch-cache.js
+++ b/dist/server/lib/incremental-cache/fetch-cache.js
@@ -24,6 +24,18 @@ const CACHE_REVALIDATE_HEADER = "x-vercel-revalidate";
 const CACHE_FETCH_URL_HEADER = "x-vercel-cache-item-name";
 const CACHE_CONTROL_VALUE_HEADER = "x-vercel-cache-control";
 const DEBUG = Boolean(process.env.NEXT_PRIVATE_DEBUG_CACHE);
+
+const YELLOW = "\x1b[33m";
+const PURPLE = "\x1b[35m";
+const RESET = "\x1b[0m";
+const DARK_GRAY = "\x1b[90m";
+const RED = "\x1b[31m";
+const darkGray = (s) => `${DARK_GRAY}${s}${RESET}`;
+const yellow = (s) => `${YELLOW}${s}${RESET}`;
+const purple = (s) => `${PURPLE}${s}${RESET}`;
+const warning = (s) => `${RED}${s}${RESET}`;
+const withTime = (s) => console.log(`(${darkGray(new Date().toISOString())}) ${s}`);
+
 async function fetchRetryWithTimeout(url, init, retryIndex = 0) {
     const controller = new AbortController();
     const timeout = setTimeout(()=>{
@@ -57,7 +69,8 @@ class FetchCache {
         return true;
     }
     static isAvailable(ctx) {
-        return !!(ctx._requestHeaders["x-vercel-sc-host"] || process.env.SUSPENSE_CACHE_URL);
+        const res = !!(ctx._requestHeaders["x-vercel-sc-host"] || process.env.SUSPENSE_CACHE_URL);
+        return res;
     }
     constructor(ctx){
         this.headers = {};
@@ -168,6 +181,10 @@ class FetchCache {
             }
             return null;
         }
+        
+        if (DEBUG) {
+            console.log(yellow("*".repeat(100)));
+        }
         // memory cache is cleared at the end of each request
         // so that revalidate events are pulled from upstream
         // on successive requests
@@ -176,6 +193,7 @@ class FetchCache {
         // Get data from fetch cache. Also check if new tags have been
         // specified with the same cache key (fetch URL)
         if (this.cacheEndpoint && (!data || !hasFetchKindAndMatchingTags)) {
+            if (DEBUG) console.log(`mem-cache MISS: ${key} tags: ${tags.join("") || fetchUrl}`);
             try {
                 const start = Date.now();
                 const fetchParams = {
@@ -184,6 +202,9 @@ class FetchCache {
                     fetchUrl: fetchUrl,
                     fetchIdx
                 };
+                if (DEBUG || fetchUrl.trim().startsWith("unstable_cache")) {
+                    withTime(yellow("[GET]") + `   ${key} ` + `${yellow("for " + fetchUrl)}`);
+                }
                 const res = await fetch(`${this.cacheEndpoint}/v1/suspense-cache/${key}`, {
                     method: "GET",
                     headers: {
@@ -194,6 +215,26 @@ class FetchCache {
                     },
                     next: fetchParams
                 });
+
+                
+                if (DEBUG) {
+                    console.dir({
+                        method: "GET",
+                        headers: {
+                            ...this.headers,
+                            [CACHE_FETCH_URL_HEADER]: fetchUrl,
+                            [CACHE_TAGS_HEADER]: (tags == null ? void 0 : tags.join(",")) || "",
+                            [_constants.NEXT_CACHE_SOFT_TAGS_HEADER]: (softTags == null ? void 0 : softTags.join(",")) || ""
+                        },
+                        next: fetchParams
+                    });
+                    console.dir({
+                        headers: Object.fromEntries(Array.from(res.headers.entries())),
+                        status: res.status,
+                        ok: res.ok,
+                    });
+                }
+
                 if (res.status === 429) {
                     const retryAfter = res.headers.get("retry-after") || "60000";
                     rateLimitedUntil = Date.now() + parseInt(retryAfter);
@@ -244,7 +285,10 @@ class FetchCache {
                     console.error(`Failed to get from fetch-cache`, err);
                 }
             }
+        } else {
+            if (DEBUG) console.log(`mem-cache HIT: ${key} tags: ${tags.join("") || fetchUrl}`);
         }
+        if (DEBUG) console.log(yellow("*".repeat(50)));
         return data || null;
     }
     async set(...args) {
@@ -257,11 +301,16 @@ class FetchCache {
             }
             return;
         }
+
+        
+        if (DEBUG) console.log(purple("*".repeat(100)));
+
         memoryCache == null ? void 0 : memoryCache.set(key, {
             value: data,
             lastModified: Date.now()
         });
         if (this.cacheEndpoint) {
+            if (DEBUG) console.log(`mem-cache SET: ${key} tags: ${tags.join("") || fetchUrl}`);
             try {
                 const start = Date.now();
                 if (data !== null && "revalidate" in data) {
@@ -285,6 +334,11 @@ class FetchCache {
                     fetchUrl,
                     fetchIdx
                 };
+
+                if (DEBUG || fetchUrl.trim().startsWith("unstable_cache")) {
+                    withTime(`${purple("[POST]")}  ${key + yellow(" for ")}${fetchUrl}`); 
+                }
+                
                 const res = await fetch(`${this.cacheEndpoint}/v1/suspense-cache/${key}`, {
                     method: "POST",
                     headers: {
@@ -295,6 +349,24 @@ class FetchCache {
                     body: body,
                     next: fetchParams
                 });
+                if (DEBUG) {
+                    console.dir({
+                        method: "POST",
+                        headers: {
+                            "x-vercel-revalidate": this.headers["x-vercel-revalidate"],
+                            [CACHE_FETCH_URL_HEADER]: fetchUrl || "",
+                            [CACHE_TAGS_HEADER]: (tags == null ? void 0 : tags.join(",")) || ""
+                        },
+                        next: fetchParams
+                    }, { depth: 3 });
+                    
+                    console.dir({
+                        headers: Object.fromEntries(Array.from(res.headers.entries())),
+                        status: res.status,
+                        ok: res.ok,
+                    });
+                }
+
                 if (res.status === 429) {
                     const retryAfter = res.headers.get("retry-after") || "60000";
                     rateLimitedUntil = Date.now() + parseInt(retryAfter);
@@ -313,6 +385,7 @@ class FetchCache {
                 }
             }
         }
+        if (DEBUG) console.log(purple("*".repeat(50)))
         return;
     }
 }
diff --git a/dist/server/lib/incremental-cache/index.js b/dist/server/lib/incremental-cache/index.js
index 754eee87cf0d60f034cb6c05ad87ac9ada5c93fe..0688d9b72ad0d05f3846e2c2d3f4f8d62a85f583 100644
--- a/dist/server/lib/incremental-cache/index.js
+++ b/dist/server/lib/incremental-cache/index.js
@@ -50,18 +50,19 @@ class IncrementalCache {
         this.hasCustomCacheHandler = Boolean(CurCacheHandler);
         if (!CurCacheHandler) {
             if (fs && serverDistDir) {
-                if (debug) {
-                    console.log("using filesystem cache handler");
-                }
                 CurCacheHandler = _filesystemcache.default;
             }
             if (_fetchcache.default.isAvailable({
                 _requestHeaders: requestHeaders
-            }) && minimalMode && fetchCache) {
+            }) && fetchCache) {
                 if (debug) {
                     console.log("using fetch cache handler");
                 }
                 CurCacheHandler = _fetchcache.default;
+            } else {
+                if (debug) {
+                    console.log("using filesystem cache handler");
+                }
             }
         } else if (debug) {
             console.log("using custom cache handler", CurCacheHandler.name);
diff --git a/dist/server/web/spec-extension/unstable-cache.js b/dist/server/web/spec-extension/unstable-cache.js
index 1cbb26c565dea760e48f2668e0f7e81582ea51d4..7c6c753f0ba5d3496d5af7b522aa64d08647e7ac 100644
--- a/dist/server/web/spec-extension/unstable-cache.js
+++ b/dist/server/web/spec-extension/unstable-cache.js
@@ -12,6 +12,18 @@ const _constants = require("../../../lib/constants");
 const _patchfetch = require("../../lib/patch-fetch");
 const _staticgenerationasyncstorageexternal = require("../../../client/components/static-generation-async-storage.external");
 let noStoreFetchIdx = 0;
+
+const YELLOW = "\x1b[33m";
+const PURPLE = "\x1b[35m";
+const RESET = "\x1b[0m";
+const DARK_GRAY = "\x1b[90m";
+const RED = "\x1b[31m";
+const darkGray = (s) => `${DARK_GRAY}${s}${RESET}`;
+const yellow = (s) => `${YELLOW}${s}${RESET}`;
+const purple = (s) => `${PURPLE}${s}${RESET}`;
+const warning = (s) => `${RED}${s}${RESET}`;
+const withTime = (s) => console.log(`(${darkGray(new Date().toISOString())}) ${s}`);
+
 async function cacheNewResult(result, incrementalCache, cacheKey, tags, revalidate, fetchIdx, fetchUrl) {
     await incrementalCache.set(cacheKey, {
         kind: "FETCH",
@@ -132,6 +144,7 @@ function unstable_cache(cb, keyParts, options = {}) {
                                 store.pendingRevalidates = {};
                             }
                             // We run the cache function asynchronously and save the result when it completes
+                            withTime(`${darkGray("[STALE]")} ${cacheKey}` + darkGray(` for ${fetchUrl}`));
                             store.pendingRevalidates[invocationKey] = _staticgenerationasyncstorageexternal.staticGenerationAsyncStorage.run({
                                 ...store,
                                 // force any nested fetches to bypass cache so they revalidate
@@ -155,10 +168,16 @@ function unstable_cache(cb, keyParts, options = {}) {
                 // when the unstable_cache call is revalidated
                 fetchCache: "force-no-store",
                 isUnstableCacheCallback: true
-            }, cb, ...args);
-            if (!store.isDraftMode) {
-                cacheNewResult(result, incrementalCache, cacheKey, tags, options.revalidate, fetchIdx, fetchUrl);
-            }
+            }, cb, ...args).then(async (result) => {
+                // In App Router we return the stale result and revalidate in the background
+                if (!store.pendingRevalidates) {
+                    store.pendingRevalidates = {};
+                }
+                if (!store.isDraftMode) {
+                    const cachedResult = cacheNewResult(result, incrementalCache, cacheKey, tags, options.revalidate, fetchIdx, fetchUrl);
+                    store.pendingRevalidates[invocationKey] = cachedResult;
+                }
+            });
             return result;
         } else {
             noStoreFetchIdx += 1;
@@ -212,7 +231,7 @@ function unstable_cache(cb, keyParts, options = {}) {
                 isStaticGeneration: false,
                 prerenderState: null
             }, cb, ...args);
-            cacheNewResult(result, incrementalCache, cacheKey, tags, options.revalidate, fetchIdx, fetchUrl);
+            await cacheNewResult(result, incrementalCache, cacheKey, tags, options.revalidate, fetchIdx, fetchUrl);
             return result;
         }
     };
